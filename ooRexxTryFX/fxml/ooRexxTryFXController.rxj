/* redirect output monitor destination */
-- .local~fx.rexxEngine = .bsf~new("org.apache.bsf.BSFManager")~loadScriptingEngine("rexx")
-- .output~destination(.GUIOutputStream~new("STDOUT")) -- we need to change the new Rexx engine's .output !

::requires "FXRexxEngine.rxj"    -- get access to the RXRexxEngine class


::routine runApp public
    use arg slotDir

    tgtOutput=.my.app~ooRexxTryFX.fxml~output   -- get "Output" TextArea object
    tgtOutput~setText("")  -- delete output area

-- rgf: hier k?nnte in Zukunft entschieden werden, welche RexxEngine zur Ausf?hrung benutzt werden soll
    fxRexxEngine=.FXRexxEngine~latestRexxEngine   -- if a RexxEngine available it can be retrieved
    if fxRexxEngine=.nil then      -- no RexxEngine created so far, create one
    do
         -- usage                  (input,output,error,debugInput,traceOutput)
         -- TODO: erg?nzen, wenn die anderen JavaFX-Objekte verf?gbar sind!
       fxRexxEngine=.FXRexxEngine~new(     , tgtOutput)
       .local~fx.RexxEngine=fxRexxEngine     -- diese soll die Default-RexxEngine sein (.fx.RexxEngine)
    end

  --  signal on syntax
    ScriptContext = slotDir~scriptContext
    CodeArea = .TabManager~getInputArea
    Code = CodeArea~getText

-- rgf: why executing on a separate thread?
    et=.ExecuteThread~new(fxRexxEngine~rexxEngine, Code)
    runnable = BsfCreateRexxProxy(et, ,.java.lang.Runnable)
    .java.lang.Thread~new(runnable)~~bsf.dispatch("start")              -- Run code in separate thread
say "Rexx program started," .dateTime~new", et~busy="pp(et~busy) "et~done="pp(et~done)

    /*@get(SplitPane)*/
    /* grow the Output Area: */
    SplitPane~setDividerPosition(0, 0.65)   -- arguments: index, position

say "Rexx program may have ended already," .dateTime~new", et~busy="pp(et~busy) "et~done="pp(et~done)
say "---"


/* --------------------------------------------------------------------------------------------------- */


-- rgf: jetzt ein drittes
::class ExecuteThread
::attribute res               -- attribute will receive the return value from the Rexx program; fetch it after "done" got .true
::attribute busy              -- indicates whether Rexx program is executing on separate thread
::attribute done              -- indicate that Rexx script ran
::method init
   expose rexxEngine Code args busy done
   use strict arg rexxEngine, Code, args=.nil
   res=.nil                   -- set res attribute explicitly to .nil
   done=.false                -- indicate that Rexx program was not run/is not finished
   busy=.false                -- indicate Rexx program not running (yet)

::method run
   expose rexxEngine Code args res busy done
   busy=.true                 -- indicate Rexx program is running
   res=.fx.rexxEngine~rexxEngine~apply("tmp.code",0,0,Code,.nil,args) --java.lang.String source, int lineNo, int columnNo, java.lang.Object funcBody, java.util.Vector paramNames, java.util.Vector arguments)
   busy=.false                -- indicate Rexx program is not running anymore
   done=.true                 -- indicate that Rexx program has run and is finished, save to fetch result "res"
   say pp(res)



/* --------------------------------------------------------------------------------------------------- */

::routine saveFile public
    use arg slotDir

    if .TabManager~alreadySavedFile <> .nil then
        skipDialog = .true                                  /* if a file was previously selected to open or save, use it
                                                               to save it the new content into that file, therefore skipping the
                                                               file selection dialog */
    else
        skipDialog = .false                                 -- default behaviour: do not skip the dialog

   call saveFileAs slotDir, skipDialog

/* --------------------------------------------------------------------------------------------------- */

::routine saveFileAs public
    use arg slotDir, skipDialog = .false    -- fetch the slotDir argument (BSF4ooRexx adds this as the last argument at the Java side)
    scriptContext = slotDir~scriptContext   -- get the slotDir (the last) argument, get the entry "SCRIPTCONTEXT"

    Code = .TabManager~getInputArea~getText

    FileChooser = .bsf~new("javafx.stage.FileChooser")                  -- instantiate the javafx FileChooser class
    FileChooser~setTitle("Save file as")                                -- set the title for the FileChooser Dialog
    extensions = bsf.createJavaArrayOf("java.lang.String", "*.*")
    filter = .bsf~new("javafx.stage.FileChooser$ExtensionFilter", "all files", extensions)
    FileChooser~getExtensionFilters~add(filter)

    alreadySavedFile = .TabManager~alreadySavedFile

    if alreadySavedFile <> .nil then do
      fileObj = .bsf~new("java.io.File", alreadySavedFile)
      FileChooser~setInitialDirectory( fileObj~getParentFile )    -- predefine the directory
      FileChooser~setInitialFileName( fileObj~toString )          -- predefine the filename
    end
    else do
      /* set the current directory as default */
      FileChooser~setInitialDirectory( .bsf~new("java.io.File", Directory()) )                     -- set to this directory
    end
    if \skipDialog then
        file = FileChooser~showSaveDialog(.my.app~primaryStage)             -- show the save dialog
    else
        file = .bsf~new("java.io.File", alreadySavedFile)

    if file \= .nil then do

        filepath = file~toString
        rexxStream = .stream~new(filepath)                                -- create an instance of rexx' stream class
        rexxStream~open("both replace")                                   /* replace the first line with the content
                                                                             instead of adding another */
        do line over Code
          rexxStream~lineOut(line) /*todo: remove the last line */                                         -- write the Code into that file
        end
        rexxStream~close                                                  -- release the lock on this file

        /*todo: notification instead of alerts
        alert = .fx.alert~new(.fx.Alert.Type~information)   -- create an error alert
        alert~setTitle("success")
        alert~setHeaderText(.nil)
        alert~setContentText("File successfully saved!")
        alert~showAndWait
        */
        .TabManager~saveFilepath(filepath)                                     -- save the file to eventually skip the dialog next time
        filename = filespec("Name", filepath)
        .TabManager~getCurrentTab~setText(filename)
        .OpenRecentMenuManager~updateMenu(filepath)
        say time()": File successfully saved!"      --todo: no output??
        .my.app~ooRexxTryFX.fxml~SplitPane~setDividerPosition(0, 0.75)   -- arguments: index, position
    end

/* --------------------------------------------------------------------------------------------------- */

::routine loadFile public
    use arg slotDir
    scriptContext = slotDir~scriptContext
    TextArea = .TabManager~getInputArea
    Code = TextArea~getText

    if slotDir~userData <> .nil then do
      userData = slotDir~userData
      if userData~useCurrentFile <> .nil then do                       -- called by "Application" -> "Reload"
        savedFilepath = .TabManager~alreadySavedFile
        if savedFilepath = .nil then do
          say time()": Reloading not possible"
          return                                 -- leave the method, reloading not possible
        end
        file = .bsf~new("java.io.File", savedFilepath)
      end
      else if userData~useSpecificFile <> .nil then do
        filepath = userData~useSpecificFile
        file = .bsf~new("java.io.File", filepath)
      end
    end
    else do                                                               -- need to open a filechooser dialog
      FileChooser = .bsf~new("javafx.stage.FileChooser")                  -- instantiate the javafx FileChooser class
      FileChooser~setTitle("Load file")                                   -- set the title for the FileChooser Dialog

      if .TabManager~alreadySavedFile <> .nil then do
        fileObj = .bsf~new("java.io.File", .TabManager~alreadySavedFile)
        initialDirectory = fileObj~getParentFile                          -- get a reference to the parent directory
      end
      else
        initialDirectory = .bsf~new("java.io.File", Directory())

      FileChooser~setInitialDirectory(initialDirectory)
      file = FileChooser~showOpenDialog(.my.app~primaryStage)             -- show the dialog to load a file
    end
    /* TODO:
    if .TabManager~getCurrentTab~getText~equals("Untitled Document") then
      --> open in this tab
      else: open in new tab
      */
    if file \= .nil then do
        filepath = file~toString                                            -- cast the "File" obj to a "String", thereby extracting the filepath
        rexxStream = .stream~new(filepath)
        loadedCode = ""
		    do line over rexxStream
			     loadedCode ||= line "0a"x                                  /* append the next line to the string loadedCode */
        end
        TextArea~setText(loadedCode)
        rexxStream~close
        say time() || ": File successfully opened!"
        --todo: make this a statusbar notification
        .TabManager~saveFilepath(filepath)
        .TabManager~getCurrentTab~setText( filespec("name", filepath) )
        .OpenRecentMenuManager~updateMenu(filepath)
    end

/* --------------------------------------------------------------------------------------------------- */


/** Class that outputs strings to TextArea.
*/
::class fxOutputStream subclass outputStream -- 2017-04-03, rgf
::method init
  expose fxTextArea           -- the text area to output to
  use arg fxTextArea          -- fetch TextArea to output to

::method charOut
  expose fxTextArea           -- get access to the TextArea we want to write to
  use strict arg string="", charPosition=(-1)     -- ignore position, we have a transient stream here
  if string<>"" then fxTextArea~appendText(string)  -- output received characters
  return 0              -- transient stream, return 0 as position

::method lineOut
  forward message "SAY" -- let the SAY method carry out the operation

::method say
  expose fxTextArea           -- get access to the TextArea we want to write to
  use arg string="", linePosition=(-1)            -- ignore position, we have a transient stream here
  if string<>"" then fxTextArea~appendText(string || "0a"x)  -- output received characters, append NL character


/*
::class fxInputStream
  expose fxTextInputControl   -- the text input to get data from

...

*/


