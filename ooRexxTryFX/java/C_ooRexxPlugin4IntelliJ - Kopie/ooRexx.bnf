{
  parserClass="org.oorexx.ide.parser.OoRexxParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="OoRexx"
  psiImplClassSuffix="Impl"
  psiPackage="org.oorexx.ide.lang.psi"
  psiImplPackage="org.oorexx.ide.lang.psi.impl"

  elementTypeHolderClass="org.oorexx.ide.lang.OoRexxTypes"
  elementTypeClass="org.oorexx.ide.lang.OoRexxElementType"
  tokenTypeClass="org.oorexx.ide.lexer.token.OoRexxTokenType"

  parserImports=["static org.oorexx.ide.intellij.util.ResourceDelimiterParser.*"]


    tokens = [
            SEMICOLON = ';'
            EQ = '='
            BACKSLASH = '\'
            STRING_LITERAL = 'regexp:\"\p{Alpha}*\"'
            EOL = "\n"


            EOL_COMMENT = 'EOL_COMMENT'
            BLOCK_COMMENT = 'BLOCK_COMMENT'

            SHEBANG_LINE = '#!/bin/bash'


            identifier  = 'regexp:\p{Alpha}\w*'

            RESOURCE = 'RESOURCE'
            RESOURCE_DATA = 'RESOURCE_DATA'
            PROLOG = 'PROLOG'
            NOPROLOG = 'NOPROLOG'
            NAMESPACE = 'NAMESPACE'
            CONDITION = 'CONDITION'
            PACKAGE = 'PACKAGE'

            FALSE = '.FALSE'
            NIL = '.NIL'
            TRUE = '.TRUE'
            ATTRIBUTE = 'ATTRIBUTE'
            ANNOTATE = 'ANNOTATE'
            CLASS = 'CLASS'
            CONSTANT = 'CONSTANT'
            METHOD = 'METHOD'
            OPTIONS = 'OPTIONS'
            REQUIRES = 'REQUIRES'
            ROUTINE = 'ROUTINE'
            ABSTRACT = 'ABSTRACT'
            ATTRIBUTE = 'ATTRIBUTE'
            CLASS = 'CLASS'
            DIGITS = 'DIGITS'
            EXTERNAL = 'EXTERNAL'
            FORM = 'FORM'
            FUZZ = 'FUZZ'
            GET = 'GET'
            GUARDED = 'GUARDED'
            INHERIT = 'INHERIT'
            LIBRARY = 'LIBRARY'
            METACLASS = 'METACLASS'
            MIXINCLASS = 'MIXINCLASS'
            PRIVATE = 'PRIVATE'
            PROTECTED = 'PROTECTED'
            PUBLIC = 'PUBLIC'
            SET = 'SET'
            SUBCLASS = 'SUBCLASS'
            TRACE = 'TRACE'
            UNGUARDED = 'UNGUARDED'
            UNPROTECTED = 'UNPROTECTED'
            EOL_WHITE_SPACE = 'EOL_WHITE_SPACE'
            SELF = 'SELF'
            ADDRESS = 'ADDRESS'
            CONCATINATION_WHITE_SPACE = 'CONCATINATION_WHITE_SPACE'
            ARG = 'ARG'
            CALL = 'CALL'
            DO = 'DO'
            DROP = 'DROP'
            EXIT = 'EXIT'
            EXPOSE = 'EXPOSE'
            FORWARD = 'FORWARD'
            GUARD = 'GUARD'
            IF = 'IF'
            INTERPRET = 'INTERPRET'
            ITERATE = 'ITERATE'
            INDEX = 'INDEX'
            ITEM = 'ITEM'
            LEAVE = 'LEAVE'
            LOOP = 'LOOP'
            NOP = 'NOP'
            NUMERIC = 'NUMERIC'
            OPTIONS = 'OPTIONS'
            PARSE = 'PARSE'
            PROCEDURE = 'PROCEDURE'
            PULL = 'PULL'
            PUSH = 'PUSH'
            QUEUE = 'QUEUE'
            RAISE = 'RAISE'
            REPLY = 'REPLY'
            RETURN = 'RETURN'
            SAY = 'SAY'
            SELECT = 'SELECT'
            SIGNAL = 'SIGNAL'
            TRACE = 'TRACE'
            USE = 'USE'
            ADDITIONAL = 'ADDITIONAL'
            ANY = 'ANY'
            ARG = 'ARG'
            ARGUMENTS = 'ARGUMENTS'
            ARRAY = 'ARRAY'

            BY = 'BY'
            CASELESS = 'CASELESS'
            CLASS = 'CLASS'
            COMMANDS = 'COMMANDS'
            CONTINUE = 'CONTINUE'
            DESCRIPTION = 'DESCRIPTION'
            DIGIT = 'DIGIT'
            DROP = 'DROP'
            ELSE = 'ELSE'
            END = 'END'
            ENGINEERING = 'ENGINEERING'
            ERROR = 'ERROR'
            EXIT = 'EXIT'
            EXPOSE = 'EXPOSE'
            FAILURE = 'FAILURE'
            FOR = 'FOR'
            FOREVER = 'FOREVER'
            FORM = 'FORM'
            FUZZ = 'FUZZ'
            HALT = 'HALT'
            INTERMEDIATES = 'INTERMEDIATES'
            LABEL = 'LABEL'
            LABELS = 'LABELS'
            LINEIN = 'LINEIN'
            LINEOUT = 'LINEOUT'
            LOSTDIGITS = 'LOSTDIGITS'
            LOWER = 'LOWER'
            MESSAGE = 'MESSAGE'
            NAME = 'NAME'
            NOMETHOD = 'NOMETHOD'
            NORMAL = 'NORMAL'
            NOSTRING = 'NOSTRING'
            NOTREADY = 'NOTREADY'
            NOVALUE = 'NOVALUE'
            OFF = 'OFF'
            ON = 'ON'
            OTHERWISE = 'OTHERWISE'
            OVER = 'OVER'
            PROPAGATE = 'PROPAGATE'
            PULL = 'PULL'
            RESULTS = 'RESULTS'
            RETURN = 'RETURN'
            SCIENTIFIC = 'SCIENTIFIC'
            SOURCE = 'SOURCE'
            STRICT = 'STRICT'
            SYNTAX = 'SYNTAX'
            THEN = 'THEN'
            TO = 'TO'
            UNTIL = 'UNTIL'
            UPPER = 'UPPER'
            USER = 'USER'
            VALUE = 'VALUE'
            VAR = 'VAR'
            VERSION = 'VERSION'
            WHEN = 'WHEN'
            WHILE = 'WHILE'
            WITH = 'WITH'
            DELEGATE = 'DELEGATE'
            IDENTIFIER = 'IDENTIFIER'
            INTEGER_LITERAL = 'INTEGER_LITERAL'
            FLOAT_LITERAL = 'FLOAT_LITERAL'
            STRING_LITERAL = 'STRING_LITERAL'
            BINARY_STRING_LITERAL = 'BINARY_STRING_LITERAL'
            HEX_STRING_LITERAL = 'HEX_STRING_LITERAL'
            BLOCK_COMMENT = 'BLOCK_COMMENT'
            EOL_COMMENT = 'EOL_COMMENT'
            DOC_COMMENT = 'DOC_COMMENT'
            SHEBANG_LINE = 'SHEBANG_LINE'

            TILDE = '~'
            PLUS = '+'
            MINUS = '-'
            NEGATION = '\'
            MUL = '*'
            DIV = '/'
            INTDIV = 'INTDIV'
            STRINGCONCAT = 'STRINGCONCAT'
            EQ = '='
            EQEQ = 'EQEQ'
            STIRCTLT = 'STIRCTLT'
            STIRCTGT = 'STIRCTGT'
            NOTEQ = 'NOTEQ'
            STRICTNOTGT = 'STRICTNOTGT'
            STRICTNOTLT = 'STRICTNOTLT'
            STRICTNOTEQ = 'STRICTNOTEQ'
            GTEQ = 'GTEQ'
            STRICTGTEQ = 'STRICTGTEQ'
            LTEQ = 'LTEQ'
            STRICTLTEQ = 'STRICTLTEQ'
            AND = 'AND'
            XOR = 'XOR'
            PIPE = 'PIPE'
            COLON = ':'
            FUNC_IDENTIFIER = 'FUNC_IDENTIFIER'
            COMMA = ','
            DOT = '.'
            GT = '>'
            LT = '<'
            LPAREN = '('
            RPAREN = ')'
            LBRACK = '['
            RBRACK = ']'
            SEMICOLON = ';'
            SUPER = 'SUPER'
            STATE = 'STATE'
            COMMAND = 'COMMAND'
            COUNT = 'COUNT'
            CREATE = 'CREATE'
            EXIST = 'EXIST'
            OPEN = 'OPEN'
            DELETE = 'DELETE'
            ENV_IDENTIFIER = 'ENV_IDENTIFIER'
            ENV_LOCAL = '.LOCAL'
            ENV_ENVIRONMENT = '.ENVIRONMENT'
            BIF_ABBREV = 'BIF_ABBREV'
            BIF_ABS = "BIF_ABS"
            BIF_ADDRESS =   "BIF_ADDRESS"
            BIF_ARG =  "BIF_ARG"
            BIF_B2X =   "BIF_B2X"
            BIF_BEEP =  "BIF_BEEP"
            BIF_BITAND =   "BIF_BITAND"
            BIF_BITOR =   "BIF_BITOR"
            BIF_BITXOR =   "BIF_BITXOR"
            BIF_C2D =  "BIF_C2D"
            BIF_C2X =   "BIF_C2X"
            BIF_CENTER =   "BIF_CENTER"
            BIF_CENTRE =  "BIF_CENTRE"
            BIF_CHANGESTR =   "BIF_CHANGESTR"
            BIF_CHARIN =   "BIF_CHARIN"
            BIF_CHAROUT =   "BIF_CHAROUT"
            BIF_CHARS =   "BIF_CHARS"
            BIF_COMPARE =  "BIF_COMPARE"
            BIF_CONDITION =  "BIF_CONDITION"
            BIF_COPIES =   "BIF_COPIES"
            BIF_COUNTSTR =  "BIF_COUNTSTR"
            BIF_D2C =  "BIF_D2C"
            BIF_D2X =  "BIF_D2X"
            BIF_DATATYPE =   "BIF_DATATYPE"
            BIF_DATE = "BIF_DATE"
            BIF_DELSTR =   "BIF_DELSTR"
            BIF_DELWORD =   "BIF_DELWORD"
            BIF_DIGITS =   "BIF_DIGITS"
            BIF_DIRECTORY =   "BIF_DIRECTORY"
            BIF_ENDLOCAL =  "BIF_ENDLOCAL"
            BIF_ERRORTEXT =   "BIF_ERRORTEXT"
            BIF_FILESPEC =  "BIF_FILESPEC"
            BIF_FORM =   "BIF_FORM"
            BIF_FORMAT =  "BIF_FORMAT"
            BIF_FUZZ =  "BIF_FUZZ"
            BIF_INSERT =  "BIF_INSERT"
            BIF_LASTPOS =  "BIF_LASTPOS"
            BIF_LEFT =  "BIF_LEFT"
            BIF_LENGTH =  "BIF_LENGTH"
            BIF_LINEIN =  "BIF_LINEIN"
            BIF_LINEOUT =  "BIF_LINEOUT"
            BIF_LINES =  "BIF_LINES"
            BIF_LOWER =  "BIF_LOWER"
            BIF_MAX =  "BIF_MAX"
            BIF_MIN =  "BIF_MIN"
            BIF_OVERLAY =   "BIF_OVERLAY"
            BIF_POS =   "BIF_POS"
            BIF_QUALIFY =  "BIF_QUALIFY"
            BIF_QUEUED =  "BIF_QUEUED"
            BIF_RANDOM =  "BIF_RANDOM"
            BIF_REVERSE =   "BIF_REVERSE"
            BIF_RIGHT =  "BIF_RIGHT"
            BIF_RXFUNCADD =   "BIF_RXFUNCADD"
            BIF_RXFUNCDROP =  "BIF_RXFUNCDROP"
            BIF_RXFUNCQUERY =  "BIF_RXFUNCQUERY"
            BIF_RXQUEUE =  "BIF_RXQUEUE"
            BIF_SETLOCAL =  "BIF_SETLOCAL"
            BIF_SIGN =  "BIF_SIGN"
            BIF_SOURCELINE =  "BIF_SOURCELINE"
            BIF_SPACE =  "BIF_SPACE"
            BIF_STREAM =  "BIF_STREAM"
            BIF_STRIP =  "BIF_STRIP"
            BIF_SUBSTR =  "BIF_SUBSTR"
            BIF_SUBWORD =  "BIF_SUBWORD"
            BIF_SYMBOL =  "BIF_SYMBOL"
            BIF_TIME =  "BIF_TIME"
            BIF_TRACE =  "BIF_TRACE"
            BIF_TRANSLATE =  "BIF_TRANSLATE"
            BIF_TRUNC =  "BIF_TRUNC"
            BIF_UPPER =  "BIF_UPPER"
            BIF_USERID =  "BIF_USERID"
            BIF_VALUE = "BIF_VALUE"
            BIF_VAR = "BIF_VAR"
            BIF_VERIFY = "BIF_VERIFY"
            BIF_WORD = "BIF_WORD"
            BIF_WORDINDEX =  "BIF_WORDINDEX"
            BIF_WORDLENGTH =  "BIF_WORDLENGTH"
            BIF_WORDPOS =   "BIF_WORDPOS"
            BIF_WORDS =  "BIF_WORDS"
            BIF_X2B =  "BIF_X2B"
            BIF_X2C =  "BIF_X2C"
            BIF_X2D =   "BIF_X2D"
            BIF_XRANGE =   "BIF_XRANGE"
        ]

}


file ::= shebang? (new_line | instruction)* (directive)*

private meta paren ::= <<p>> | (LPAREN (<<paren  <<p>>>>| <<p>>) RPAREN)
environment_id ::= ENV_IDENTIFIER | ENV_ENVIRONMENT | ENV_LOCAL
id ::= (namespace_prefix (new_line* !assignments_and_keywords))? (identifier | environment_id | keyword_list)
keyword_list ::= (ROUTINE) | (METHOD) | (STATE) | (COMMAND) | (OPEN) | (DELETE) | (EXIST) | (CREATE) | (COUNT) | (SUPER) | (PACKAGE) | (ABSTRACT) | (ANNOTATE) | (ATTRIBUTE) | (CLASS) | (CONDITION) | (DIGITS) | (EXTERNAL) | (FORM) | (FUZZ) | (GET) | (GUARDED) | (INHERIT) | (LIBRARY) | (METACLASS) | (MIXINCLASS) | (NAMESPACE) | (NOPROLOG) | (PRIVATE) | (PROLOG) | (PROTECTED) | (PUBLIC) | (RESOURCE) | (RESOURCE_DATA) | (SET) | (SUBCLASS) | (TRACE) | (UNGUARDED) | (UNPROTECTED) | (ADDRESS) | (ARG) | (CALL) | (DO) | (DROP) | (EXIT) | (EXPOSE) | (FORWARD) | (GUARD) | (IF) | (INTERPRET) | (ITERATE) | (LEAVE) | (LOOP) | (NOP) | (NUMERIC) | (OPTIONS) | (PARSE) | (PROCEDURE) | (PULL) | (PUSH) | (QUEUE) | (RAISE) | (REPLY) | (RETURN) | (SAY) | (SELECT) | (SIGNAL) | (TRACE) | (USE) | (SELF) | (ADDITIONAL) | (ANY) | (ARG) | (ARGUMENTS) | (ARRAY) | (BY) | (CASELESS) | (CLASS) | (COMMANDS) | (CONTINUE) | (DESCRIPTION) | (DIGIT) | (DROP) | (ELSE) | (END) | (ENGINEERING) | (ERROR) | (EXIT) | (EXPOSE) | (FAILURE) | (FOR) | (FOREVER) | (FORM) | (FUZZ) | (HALT) | (INTERMEDIATES) | (LABEL) | (LABELS) | (LINEIN) | (LINEOUT) | (LOSTDIGITS) | (LOWER) | (MESSAGE) | (NAME) | (NOMETHOD) | (NORMAL) | (NOSTRING) | (NOTREADY) | (NOVALUE) | (OFF) | (ON) | (OTHERWISE) | (OVER) | (PROPAGATE) | (PULL) | (RESULTS) | (RETURN) | (SCIENTIFIC) | (SOURCE) | (STRICT) | (SYNTAX) | (THEN) | (TO) | (UNTIL) | (UPPER) | (USER) | (VALUE) | (VAR) | (VERSION) | (WHEN) | (WHILE) | (WITH) | (ITEM) | (INDEX)

private assignments_and_keywords ::= ( assignment |  <<excluding_expr keyword_list>> | (keyword_instruction) )
instruction ::= (SEMICOLON | label_instruction | ((assignments_and_keywords | (!END keyword_list))  instruction_terminator))

function_call ::= built_in_functions | (namespace_prefix? function_call_without_namespace)
private function_call_without_namespace ::= ((FUNC_IDENTIFIER | built_in_functions_keyword_list) LPAREN (COMMA | parameter_expr)* RPAREN){pin = 2}

private template_list ::= ( (expr (COMMA expr)*)+ | COMMA | DOT | template_list_eq | template_list_minus | template_list_plus)+
private template_list_plus ::= PLUS LPAREN expr RPAREN
private template_list_minus ::= MINUS LPAREN expr RPAREN
private template_list_eq ::= EQ LPAREN expr RPAREN

namespace_prefix ::= (identifier | keyword_list) COLON

shebang ::= SHEBANG_LINE
///////////////////////////////////////////////////////////////////////////////////////////////////
// Literals
///////////////////////////////////////////////////////////////////////////////////////////////////

private lit ::= string_lit | number_lit

string_lit ::= STRING_LITERAL | BINARY_STRING_LITERAL | HEX_STRING_LITERAL
number_lit ::= INTEGER_LITERAL | FLOAT_LITERAL | bool_lit
bool_lit ::= FALSE | TRUE

id_with_lit ::= id | lit
id_with_number ::= id | number_lit

symbol_or_string ::= STRING_LITERAL | id
symbol_or_string_or_function ::= symbol_or_string | function_call
symbol_or_string_or_keyword ::= symbol_or_string | keyword_list | lit
new_line ::= EOL

///////////////////////////////////////////////////////////////////////////////////////////////////
// Message Term
///////////////////////////////////////////////////////////////////////////////////////////////////

standalone_keyword_message_term ::= &(keyword_list TILDE) expr

message_term ::=  (message_term_receiver message_term_tail+)

message_term_tail ::= (message_term_tilde | message_term_brack)
message_term_brack ::= (LBRACK (expr | COMMA)* RBRACK)
message_term_tilde ::= (message_term_operator
                               (
                                   ((symbol_or_string COLON)? function_call_without_namespace) | ((symbol_or_string) (COLON symbol_or_string)?)
                               )
                           )
message_term_receiver ::= (keyword_list | array_term_parenthized | lit | id | function_call)
message_term_operator ::= (TILDE TILDE) | TILDE

///////////////////////////////////////////////////////////////////////////////////////////////////
// Array Term
///////////////////////////////////////////////////////////////////////////////////////////////////

array_term ::= ((expr)? COMMA (COMMA | expr | <<paren array_term>> )*)
array_term_parenthized ::= LPAREN array_term RPAREN

///////////////////////////////////////////////////////////////////////////////////////////////////
// Assignment
///////////////////////////////////////////////////////////////////////////////////////////////////

assignment ::= (message_term | id) extended_assignment expr{pin = 2}

extended_assignment ::= EQ  | ( (PLUS | MINUS | (MUL MUL) | MUL | (DIV DIV) | DIV | INTDIV | (PIPE PIPE) | PIPE | (AND AND) | AND) EQ)

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////

meta excluding_expr ::=  <<meta_expr (<<p>>)>> | (LPAREN (expr) RPAREN !<<p>>)
parameter_expr ::= DOT | <<parameter_meta_expr DUMMYOBJECT>>
expr ::= <<meta_expr DUMMYOBJECT>>
private meta parameter_meta_expr ::= !COMMA (<<expr_raw <<p>>>> (((PIPE PIPE))? !COMMA <<meta_expr <<p>>>>)*)
private meta meta_expr ::= COMMA? (<<expr_raw <<p>>>> ((COMMA |(PIPE PIPE))? <<meta_expr <<p>>>>)*)
private meta expr_raw ::= NEGATION? <<summand <<p>>>> message_term_tail* <<bool_expr <<p>>>> *
meta left bool_expr ::= comparator <<meta_expr <<p>>>>
private meta summand ::= <<factor <<p>>>> <<plus_expr <<p>>>>*
meta left plus_expr ::= plus_op <<factor <<p>>>>
private plus_op ::= '+'|'-'
private meta factor ::= NEGATION? <<primary <<p>>>> <<mul_expr <<p>>>> *

meta left mul_expr  ::= mul_op NEGATION? <<primary <<p>>>>
private mul_op ::= (MUL MUL)|MUL|(DIV DIV)| DIV|INTDIV

private meta primary ::=  (  message_term | literal_expr | <<ref_expr <<p>>>> | function_call  | paren_expr )

 meta paren_expr ::= MINUS? '(' expr ')' {pin=2}
 meta ref_expr ::= (namespace_prefix (new_line* !assignments_and_keywords))? MINUS? (identifier | environment_id | (!<<p>> keyword_list) ) // ID
literal_expr ::= string_lit | negative_numeric_expr | numeric_expr | bool_lit |  NIL
numeric_expr ::= PLUS? (INTEGER_LITERAL | FLOAT_LITERAL)
negative_numeric_expr ::= MINUS (INTEGER_LITERAL | FLOAT_LITERAL)

private comparator ::= (EQ EQ) | (LT LT EQ)| (GT GT EQ)| (LT LT) | (GT GT) | (LT GT)
| (GT LT) | (NEGATION LT LT) | (NEGATION GT GT) | (LT EQ) | (GT EQ)
| (NEGATION EQ EQ) | (NEGATION EQ)| (AND AND) | AND | PIPE  | EQ | LT | GT

///////////////////////////////////////////////////////////////////////////////////////////////////
// Label instruction
///////////////////////////////////////////////////////////////////////////////////////////////////

label_instruction ::= (symbol_or_string | keyword_list) COLON (keyword_procedure keyword_expose?)? (instruction_terminator | instruction)

///////////////////////////////////////////////////////////////////////////////////////////////////
// Directives
///////////////////////////////////////////////////////////////////////////////////////////////////
directive_start ::= (COLON COLON)

directive ::= !directive_resource_end directive_exclusive_end
private directive_exclusive_end ::= directive_start !END (directive_annotate | directive_attribute | directive_class | directive_constant | directive_method | directive_options
                            | directive_requires | directive_resource | directive_routine) {pin = 1 recoverWhile = directive_recover_rule}
private directive_recover_rule ::= !(directive_start)

///////////////////////////////////////////////////////////////////////////////////////////////////
// ::Annotate
///////////////////////////////////////////////////////////////////////////////////////////////////

directive_annotate ::= ANNOTATE
    (directive_annotate_attribute|directive_annotate_class | directive_annotate_constant | directive_annotate_method | directive_annotate_package | directive_annotate_routine)
     directive_annotate_data+ instruction_terminator{implements = "org.oorexx.ide.lang.core.DirectiveHeader"  pin = 1}
directive_annotate_attribute ::= (ATTRIBUTE id) {pin = 1}
directive_annotate_class ::=  (CLASS id)  {pin = 1}
directive_annotate_constant ::= (CONSTANT id) {pin = 1}
directive_annotate_method ::= (METHOD id) {pin = 1}
directive_annotate_package ::= PACKAGE
directive_annotate_routine ::= (ROUTINE id) {pin = 1}
directive_annotate_data ::= id lit {pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// ::Attribute
///////////////////////////////////////////////////////////////////////////////////////////////////

directive_attribute ::= ATTRIBUTE symbol_or_string (directive_attribute_get_set | directive_attribute_class
| directive_attribute_public_private | directive_attribute_guard_unguarded
| directive_attribute_unprotected_protected
| directive_attribute_abstract_delegate_external)* instruction_terminator directive_attribute_body? {implements = "org.oorexx.ide.lang.core.DirectiveHeader" pin = 1}

directive_attribute_get_set ::= GET | SET {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_attribute_class ::= CLASS {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_attribute_public_private ::= PUBLIC | (PRIVATE) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_attribute_guard_unguarded ::= GUARDED | UNGUARDED {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_attribute_unprotected_protected ::= UNPROTECTED | PROTECTED {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_attribute_abstract_delegate_external ::= ABSTRACT | (DELEGATE symbol_or_string) | (EXTERNAL string_lit) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_attribute_body ::= (keyword_expose instruction_terminator)? (!keyword_expose instruction)*
///////////////////////////////////////////////////////////////////////////////////////////////////
// ::Class
///////////////////////////////////////////////////////////////////////////////////////////////////


directive_class ::= CLASS symbol_or_string (directive_class_metaclass | directive_class_public_private | directive_class_mixinclass_subclass | directive_class_abstract)* directive_class_inherit? instruction_terminator
                                directive_class_body? {implements = "org.oorexx.ide.lang.core.DirectiveHeader" pin = 1}

directive_class_metaclass ::= METACLASS symbol_or_string {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint" pin = 1}
directive_class_public_private ::= PUBLIC | (PRIVATE) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_class_mixinclass_subclass ::=  directive_class_mixinclass | directive_class_subclass  {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_class_mixinclass ::= (MIXINCLASS symbol_or_string){pin = 1}
directive_class_subclass ::= (SUBCLASS symbol_or_string){pin = 1}
directive_class_abstract ::= ABSTRACT {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_class_inherit ::= (INHERIT symbol_or_string+) {pin = 1}

directive_class_body ::= (!(directive_start (directive_class | directive_requires | directive_routine | directive_options)) directive)*

///////////////////////////////////////////////////////////////////////////////////////////////////
// ::Constant
///////////////////////////////////////////////////////////////////////////////////////////////////

directive_constant ::= CONSTANT symbol_or_string lit? instruction_terminator{implements = "org.oorexx.ide.lang.core.DirectiveHeader" pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// ::Method
///////////////////////////////////////////////////////////////////////////////////////////////////

directive_method ::= METHOD symbol_or_string (directive_method_attribute | directive_method_class | directive_method_public_private | directive_method_guarded_unguarded | directive_method_unprotected_protected | directive_method_abstract_delegate_external)* instruction_terminator
            directive_method_body? {implements = "org.oorexx.ide.lang.core.DirectiveHeader" pin=1}
directive_method_attribute ::= ATTRIBUTE {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint" pin=1}
directive_method_class ::= CLASS {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_method_public_private ::= PUBLIC | ((PRIVATE)) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_method_guarded_unguarded ::= GUARDED | UNGUARDED {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_method_unprotected_protected ::= UNPROTECTED | PROTECTED {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_method_abstract_delegate_external ::= ABSTRACT | directive_method_delegate | directive_method_external {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_method_delegate ::= (DELEGATE symbol_or_string){pin = 1}
directive_method_external ::= (EXTERNAL symbol_or_string){pin = 1}
directive_method_body ::= (keyword_expose instruction_terminator)? (!keyword_expose instruction)*
///////////////////////////////////////////////////////////////////////////////////////////////////
// ::Options
///////////////////////////////////////////////////////////////////////////////////////////////////

directive_options ::= OPTIONS
((DIGITS number_lit) | (FORM (ENGINEERING | SCIENTIFIC)) | (FUZZ id) |
(NOVALUE (CONDITION | ERROR)) | PROLOG | NOPROLOG | (TRACE id))* instruction_terminator {implements = "org.oorexx.ide.lang.core.DirectiveHeader" pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// ::Requires
///////////////////////////////////////////////////////////////////////////////////////////////////

directive_requires::= REQUIRES (id | STRING_LITERAL) (LIBRARY | (NAMESPACE id))? instruction_terminator {implements = "org.oorexx.ide.lang.core.DirectiveHeader" pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// ::Resource
///////////////////////////////////////////////////////////////////////////////////////////////////
directive_resource ::= (directive_resource_with_delemiter | directive_resource_end_directive)
private external directive_resource_with_delemiter::= directive_resource_with_delemiter_ext
private directive_resource_end_directive::= "RESOURCE" (!(END END)symbol_or_string_or_keyword) instruction_terminator (!<<eof>> !directive_resource_end directive_resource_data)* directive_resource_end instruction_terminator {implements = "org.oorexx.ide.lang.core.DirectiveHeader"  pin = 3}
directive_resource_end ::= (directive_start END)
directive_resource_data ::= directive_resource_data_ext_call
private external directive_resource_data_ext_call ::= directive_resource_data_ext


///////////////////////////////////////////////////////////////////////////////////////////////////
// ::Routine
///////////////////////////////////////////////////////////////////////////////////////////////////
directive_routine ::= ROUTINE symbol_or_string (directive_routine_private_public | directive_routine_external)* instruction_terminator directive_routine_body{implements = "org.oorexx.ide.lang.core.DirectiveHeader"  pin = 1}
directive_routine_private_public ::= ((PRIVATE)) | PUBLIC {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
directive_routine_external ::= (EXTERNAL symbol_or_string) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"  pin = 1}

directive_routine_body ::= (!keyword_expose instruction)+ | instruction_terminator
///////////////////////////////////////////////////////////////////////////////////////////////////
// Keyword Instructions
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_instruction ::= (keyword_address | keyword_arg | keyword_call_variants | keyword_do | keyword_drop | keyword_exit | keyword_expose | keyword_forward |  keyword_guard | keyword_if | keyword_interpret | keyword_iterate | keyword_leave
| keyword_nop | keyword_numeric | keyword_options | keyword_parse | keyword_procedure | keyword_pull | keyword_push | keyword_queue | keyword_raise | keyword_reply | keyword_return | keyword_say
| keyword_select | keyword_signal | keyword_trace | keyword_use_variants ){recoverWhile = keyword_instruction_recovery}

private keyword_instruction_recovery ::= !instruction_terminator

instruction_terminator ::= (EOL+ | (SEMICOLON+ new_line*) | <<eof>>)

comma_separated_expr ::= (expr (COMMA+ expr)*)

///////////////////////////////////////////////////////////////////////////////////////////////////
// Address
///////////////////////////////////////////////////////////////////////////////////////////////////
keyword_address ::= ADDRESS ((symbol_or_string expr?) | (VALUE? expr) ){pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Arg
///////////////////////////////////////////////////////////////////////////////////////////////////
//TODO: template list?
keyword_arg ::= ARG template_list?{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Call
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_call_variants ::= (keyword_call | keyword_call_on | keyword_call_off)

keyword_call ::= CALL (symbol_or_string_or_function | ( LPAREN expr RPAREN)) comma_separated_expr?{pin = 1}

keyword_call_on ::= CALL ON (((ANY | ERROR | FAILURE | HALT | NOTREADY | (USER id)) (NAME id)) |
                            ((NAME id) (ANY | ERROR | FAILURE | HALT | NOTREADY | (USER id)))){pin = 1}
keyword_call_off ::= CALL OFF (ANY | ERROR | FAILURE | HALT | NOTREADY | (USER id)){pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Do
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_do ::= (DO | LOOP) (LABEL id)?
    (
        (keyword_do_conditional  keyword_do_repetitor) |
        (keyword_do_repetitor  keyword_do_conditional) |
        (keyword_do_conditional) |
        (keyword_do_repetitor)
    )?
instruction_terminator instruction* END (id)?{pin = 1}

private not_end ::= !(END (id)?)
keyword_do_repetitor ::= keyword_do_repetitor_1 | keyword_do_repetitor_2 | keyword_do_repetitor_3 | FOREVER | expr

private keyword_do_repetitor_1 ::= keyword_do_repetitor_assign (keyword_do_repetitor_to | keyword_do_repetitor_by | keyword_do_repetitor_for)*
private keyword_do_repetitor_2 ::= (id OVER <<excluding_expr FOR>>) keyword_do_repetitor_2_for?
private keyword_do_repetitor_2_for ::= FOR <<excluding_expr (WHILE | UNTIL)>>

private keyword_do_repetitor_3 ::= WITH (keyword_do_repetitor_index | keyword_do_repetitor_item)* OVER id keyword_do_repetitor_for?

keyword_do_repetitor_assign ::= id EQ <<excluding_expr (TO | BY | INDEX | ITEM | FOR | WHILE | UNTIL)>> {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_do_repetitor_to ::= TO <<excluding_expr (BY | FOR | INDEX | ITEM | WHILE | UNTIL)>> {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_do_repetitor_by ::= BY <<excluding_expr (TO | FOR | INDEX | ITEM | WHILE | UNTIL)>> {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_do_repetitor_for ::= FOR <<excluding_expr (TO | BY | INDEX | ITEM | WHILE | UNTIL)>> {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_do_repetitor_index ::= INDEX id {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_do_repetitor_item ::= ITEM id {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}

keyword_do_conditional ::= (WHILE | UNTIL) ( <<excluding_expr (TO | BY | INDEX | ITEM | FOR)>> | COMMA)+ {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}



///////////////////////////////////////////////////////////////////////////////////////////////////
// Drop
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_drop ::= DROP <<paren symbol_or_string>>+{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Exit
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_exit ::= EXIT expr?{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expose
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_expose ::= EXPOSE <<paren symbol_or_string>>+{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Forward
///////////////////////////////////////////////////////////////////////////////////////////////////
keyword_forward ::= FORWARD (keyword_forward_continue | keyword_forward_arguments | keyword_forward_array | keyword_forward_message | keyword_forward_class | keyword_forward_to)*{pin = 1}

keyword_forward_continue ::= CONTINUE {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_forward_arguments ::= (ARGUMENTS <<excluding_expr (MESSAGE | CONTINUE | CLASS | TO)>>) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint" pin = 1}
keyword_forward_array ::= ("ARRAY(" expr RPAREN) | (ARRAY LPAREN expr RPAREN) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}

keyword_forward_message ::= (MESSAGE <<excluding_expr (ARGUMENTS | CONTINUE | CLASS | TO)>>) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint" pin = 1}
keyword_forward_class ::= (CLASS <<excluding_expr (MESSAGE | CONTINUE | ARGUMENTS | TO)>>) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint" pin = 1}
keyword_forward_to ::= (TO <<excluding_expr (MESSAGE | CONTINUE | CLASS | ARGUMENTS)>>) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint" pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Guard
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_guard ::= GUARD (ON | OFF) (WHEN expr)?{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// IF
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_if ::= IF <<excluding_expr THEN>> instruction_terminator? THEN instruction_terminator? assignments_and_keywords (instruction_terminator keyword_if_else)?{pin = 1}
keyword_if_else ::= ELSE instruction_terminator? assignments_and_keywords{ pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Interpret
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_interpret ::= INTERPRET expr{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Iterate
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_iterate ::= ITERATE id?{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Leave
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_leave ::= LEAVE id?{pin = 1}


///////////////////////////////////////////////////////////////////////////////////////////////////
// NOP
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_nop ::= NOP

///////////////////////////////////////////////////////////////////////////////////////////////////
// Numeric
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_numeric ::= NUMERIC ((DIGITS expr?) | keyword_numeric_form | FUZZ expr?){pin = 1}
keyword_numeric_form ::= FORM (SCIENTIFIC | ENGINEERING | (VALUE? expr))

///////////////////////////////////////////////////////////////////////////////////////////////////
// Options
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_options ::= OPTIONS expr{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Parse
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_parse ::= PARSE (keyword_parse_caseless | keyword_parse_upper_lower)* keyword_arg_etc (keyword_parse_caseless | keyword_parse_upper_lower)* (template_list)? {pin = 1}

keyword_parse_upper_lower ::= UPPER | LOWER {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_parse_caseless ::= CASELESS {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_arg_etc ::= ARG | LINEIN | PULL | SOURCE | VAR (symbol_or_string) | VERSION | (VALUE <<excluding_expr WITH>> WITH) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
//parse var path2file +(lpos) theme "/" name "." ext
///////////////////////////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_procedure ::= PROCEDURE (keyword_expose)?{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Pull
///////////////////////////////////////////////////////////////////////////////////////////////////
keyword_pull ::= PULL template_list*{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// PUSH
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_push ::= PUSH expr?{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// QUEUE
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_queue::= QUEUE expr?{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// RAISE
///////////////////////////////////////////////////////////////////////////////////////////////////
keyword_raise::= RAISE (keyword_raise_error_etc | keyword_raise_options)*{pin = 1}
keyword_raise_error_etc ::= (ERROR (lit | (LPAREN expr RPAREN))) | (FAILURE (lit | (LPAREN expr RPAREN))) | HALT | LOSTDIGITS | NOMETHOD | NOSTRING | NOTREADY | NOVALUE | (SYNTAX (lit | (LPAREN expr RPAREN))) | (USER symbol_or_string) | PROPAGATE {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_raise_options ::= (keyword_raise_options_array | keyword_raise_options_description | keyword_raise_options_exit_return | keyword_raise_options_additional)+
keyword_raise_options_additional ::= ADDITIONAL <<excluding_expr (keyword_raise_error_etc_keywords | "ARRAY(" | ARRAY | DESCRIPTION | EXIT | RETURN)>> {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_raise_options_array ::= ( ("ARRAY(" (expr| COMMA)*) | (ARRAY "(" (expr| COMMA)* )) RPAREN {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}

keyword_raise_options_description ::= DESCRIPTION <<excluding_expr (keyword_raise_error_etc_keywords | "ARRAY(" | ARRAY | ADDITIONAL | EXIT | RETURN)>> {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_raise_options_exit_return ::= (EXIT <<excluding_expr (keyword_raise_error_etc_keywords | "ARRAY(" | ARRAY | ADDITIONAL | DESCRIPTION)>>?) | (RETURN <<excluding_expr (keyword_raise_error_etc_keywords | "ARRAY(" | ARRAY | ADDITIONAL | DESCRIPTION)>>?) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}



keyword_raise_error_etc_keywords ::= ERROR | FAILURE | HALT | LOSTDIGITS | NOMETHOD | NOSTRING | NOTREADY | NOVALUE | SYNTAX | USER | PROPAGATE

///////////////////////////////////////////////////////////////////////////////////////////////////
// REPLY
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_reply::= REPLY expr?{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// RETURN
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_return::= RETURN expr?{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// SAY
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_say ::= SAY expr?{pin = 1}

///////////////////////////////////////////////////////////////////////////////////////////////////
// SELECT
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_select ::= SELECT keyword_select_1 instruction_terminator (keyword_select_when )+ keyword_select_otherwise?  END symbol_or_string?{pin = 1}

private keyword_select_1 ::= (keyword_select_case | keyword_select_label)*
keyword_select_label ::= LABEL symbol_or_string {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_select_case ::= CASE <<excluding_expr (WHEN | OTHERWISE)>> {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}

keyword_select_when ::= WHEN <<excluding_expr THEN>> instruction_terminator? THEN instruction_terminator? instruction
keyword_select_otherwise ::= OTHERWISE instruction_terminator? instruction*

///////////////////////////////////////////////////////////////////////////////////////////////////
// Signal
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_signal ::= SIGNAL (keyword_signal_on | keyword_signal_off | keyword_signal_val){pin = 1}
keyword_signal_on ::= ON (keyword_signal_any_etc | keyword_signal_on_name)*
keyword_signal_on_name ::=  NAME symbol_or_string {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}
keyword_signal_off ::= OFF keyword_signal_any_etc
keyword_signal_val ::= ((VALUE? expr)| symbol_or_string)

keyword_signal_any_etc ::= ANY | ERROR | FAILURE | HALT | LOSTDIGITS | NOMETHOD | NOSTRING | NOTREADY | NOVALUE | SYNTAX | (USER symbol_or_string) {implements = "org.oorexx.ide.lang.constraint.UniqueConstraint"}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Trace
///////////////////////////////////////////////////////////////////////////////////////////////////
keyword_trace ::= TRACE (number | keyword_trace_keyword_part | symbol_or_string | (VALUE? expr)){pin = 1}
keyword_trace_keyword_part ::= "?"* (NORMAL|ALL|COMMANDS|ERROR|FAILURE|INTERMEDIATES|LABELS|OFF|RESULTS)

///////////////////////////////////////////////////////////////////////////////////////////////////
// Use
///////////////////////////////////////////////////////////////////////////////////////////////////

keyword_use_variants ::= USE (keyword_use | keyword_use_local){pin = 1}
keyword_use ::= STRICT? ARG (COMMA | (assignment | expr) )*
keyword_use_local ::= LOCAL id*

built_in_functions_keyword_list ::= BIF_ABBREV | BIF_ABS | BIF_ADDRESS | BIF_ARG | BIF_B2X | BIF_BEEP | BIF_BITAND | BIF_BITOR | BIF_BITXOR | BIF_C2D | BIF_C2X | BIF_CENTER | BIF_CENTRE | BIF_CHANGESTR | BIF_CHARIN |
BIF_CHAROUT | BIF_CHARS | BIF_COMPARE | BIF_CONDITION | BIF_COPIES | BIF_COUNTSTR | BIF_D2C | BIF_D2X | BIF_DATATYPE | BIF_DATE | BIF_DELSTR | BIF_DELWORD | BIF_DIGITS | BIF_DIRECTORY | BIF_ENDLOCAL | BIF_ERRORTEXT | BIF_FILESPEC | BIF_FORM |
BIF_FORMAT | BIF_FUZZ | BIF_INSERT | BIF_LASTPOS | BIF_LEFT | BIF_LENGTH | BIF_LINEIN | BIF_LINEOUT | BIF_LINES | BIF_LOWER | BIF_MAX | BIF_MIN | BIF_OVERLAY | BIF_POS | BIF_QUALIFY | BIF_QUEUED | BIF_RANDOM |
BIF_REVERSE | BIF_RIGHT | BIF_RXFUNCADD | BIF_RXFUNCDROP | BIF_RXFUNCQUERY | BIF_RXQUEUE | BIF_SETLOCAL | BIF_SIGN | BIF_SOURCELINE | BIF_SPACE | BIF_STREAM | BIF_STRIP | BIF_SUBSTR | BIF_SUBWORD | BIF_SYMBOL | BIF_TIME | BIF_TRACE | BIF_TRANSLATE |
BIF_TRUNC | BIF_UPPER | BIF_USERID | BIF_VALUE | BIF_VAR | BIF_VERIFY | BIF_WORD | BIF_WORDINDEX | BIF_WORDLENGTH | BIF_WORDPOS | BIF_WORDS | BIF_X2B | BIF_X2C | BIF_X2D | BIF_XRANGE


private built_in_functions ::= built_in_abbrev | built_in_abs | built_in_address | built_in_arg | built_in_b2x | built_in_beep | built_in_bitand | built_in_bitor | built_in_bitxor | built_in_c2d | built_in_c2x | built_in_center  | built_in_changestr | built_in_charin |
                               built_in_charout | built_in_chars | built_in_compare | built_in_condition | built_in_copies | built_in_countstr | built_in_d2c | built_in_d2x | built_in_datatype | built_in_date | built_in_delstr | built_in_delword | built_in_digits
                               | built_in_directory | built_in_endlocal | built_in_errortext | built_in_filespec | built_in_form | built_in_format | built_in_fuzz | built_in_insert | built_in_lastpos | built_in_left | built_in_length | built_in_linein | built_in_lineout | built_in_lines | built_in_lower | built_in_max | built_in_min | built_in_overlay
                               | built_in_pos | built_in_qualify | built_in_queued | built_in_random | built_in_reverse | built_in_right | built_in_rxfuncadd | built_in_rxfuncdrop |  built_in_rxfuncquery | built_in_rxqueue | built_in_setlocal | built_in_sign | built_in_sourceline | built_in_space | built_in_stream | built_in_strip | built_in_substr | built_in_subword | built_in_symbol
                               | built_in_time | built_in_trace | built_in_translate | built_in_trunc | built_in_upper | built_in_userid | built_in_value | built_in_var | built_in_verify | built_in_word | built_in_wordindex | built_in_wordlength | built_in_wordpos | built_in_words | built_in_x2b | built_in_x2c | built_in_x2d | built_in_xrange

built_in_abbrev ::= BIF_ABBREV LPAREN expr COMMA parameter_expr (COMMA parameter_expr) RPAREN
built_in_abs ::= BIF_ABS LPAREN parameter_expr RPAREN
built_in_address ::= BIF_ADDRESS LPAREN RPAREN
built_in_arg ::= BIF_ARG LPAREN (parameter_expr (COMMA parameter_expr)?)? RPAREN
built_in_b2x ::= BIF_B2X LPAREN parameter_expr RPAREN
built_in_beep ::= BIF_BEEP parameter_expr COMMA parameter_expr RPAREN
built_in_bitand ::= BIF_BITAND LPAREN parameter_expr COMMA parameter_expr? (COMMA parameter_expr) RPAREN
built_in_bitor ::= BIF_BITOR LPAREN parameter_expr COMMA parameter_expr? (COMMA parameter_expr) RPAREN
built_in_bitxor ::= BIF_BITXOR LPAREN parameter_expr COMMA parameter_expr? (COMMA parameter_expr) RPAREN
built_in_c2d ::= BIF_C2D LPAREN parameter_expr (COMMA parameter_expr)? RPAREN
built_in_c2x ::= BIF_C2D LPAREN parameter_expr RPAREN
built_in_center ::= (BIF_CENTER | BIF_CENTRE) LPAREN parameter_expr COMMA parameter_expr RPAREN
built_in_changestr ::= BIF_CHANGESTR LPAREN parameter_expr COMMA parameter_expr COMMA parameter_expr (COMMA parameter_expr)? RPAREN
built_in_charin ::= BIF_CHARIN LPAREN parameter_expr? COMMA parameter_expr? COMMA parameter_expr? RPAREN
built_in_charout ::= BIF_CHAROUT LPAREN parameter_expr? COMMA parameter_expr? COMMA parameter_expr? RPAREN
built_in_chars ::= BIF_CHARS LPAREN parameter_expr? RPAREN
built_in_compare ::= BIF_COMPARE LPAREN parameter_expr COMMA parameter_expr (COMMA parameter_expr)? RPAREN
built_in_condition ::= BIF_CONDITION LPAREN parameter_expr? RPAREN
built_in_copies ::= BIF_COPIES LPAREN parameter_expr COMMA parameter_expr RPAREN
built_in_countstr ::= BIF_COUNTSTR LPAREN parameter_expr COMMA parameter_expr RPAREN
built_in_d2c ::= BIF_D2C LPAREN parameter_expr (COMMA parameter_expr)? RPAREN
built_in_d2x ::= BIF_D2X LPAREN parameter_expr (COMMA parameter_expr)? RPAREN
built_in_datatype ::= BIF_DATATYPE parameter_expr (COMMA parameter_expr)? RPAREN
built_in_date ::= BIF_DATE LPAREN parameter_expr? COMMA (COMMA | (parameter_expr COMMA parameter_expr?)) COMMA parameter_expr? COMMA parameter_expr? RPAREN
built_in_delstr ::= BIF_DELSTR LPAREN parameter_expr COMMA parameter_expr (COMMA parameter_expr)? RPAREN
built_in_delword ::= BIF_DELWORD LPAREN parameter_expr COMMA parameter_expr (COMMA parameter_expr)? RPAREN
built_in_digits ::= BIF_DIGITS LPAREN RPAREN
built_in_directory ::= BIF_DIRECTORY LPAREN parameter_expr RPAREN
built_in_endlocal ::= BIF_ENDLOCAL LPAREN RPAREN
built_in_errortext ::= BIF_ERRORTEXT LPAREN parameter_expr RPAREN
built_in_filespec ::= BIF_FILESPEC LPAREN parameter_expr COMMA parameter_expr RPAREN
built_in_form ::= BIF_FORM LPAREN RPAREN
built_in_format ::= BIF_FORMAT LPAREN parameter_expr COMMA parameter_expr? COMMA parameter_expr? COMMA parameter_expr? COMMA parameter_expr? RPAREN
built_in_fuzz ::= BIF_FUZZ LPAREN RPAREN
built_in_insert ::= BIF_INSERT LPAREN parameter_expr COMMA parameter_expr COMMA parameter_expr? COMMA parameter_expr? COMMA parameter_expr? RPAREN
built_in_lastpos ::= BIF_LASTPOS LPAREN parameter_expr COMMA parameter_expr (COMMA parameter_expr? (COMMA parameter_expr)?)? RPAREN
built_in_left ::= BIF_LEFT LPAREN parameter_expr COMMA parameter_expr (COMMA parameter_expr)? RPAREN
built_in_length ::= BIF_LENGTH LPAREN parameter_expr RPAREN
built_in_linein ::= BIF_LINEIN LPAREN parameter_expr? COMMA parameter_expr? COMMA parameter_expr? RPAREN
built_in_lineout ::= BIF_LINEOUT LPAREN parameter_expr? COMMA parameter_expr? COMMA parameter_expr? RPAREN
built_in_lines ::= BIF_LINES LPAREN parameter_expr? ((COMMA NORMAL) | (COMMA COUNT))? RPAREN
built_in_lower ::= BIF_LOWER LPAREN parameter_expr (COMMA parameter_expr? (COMMA parameter_expr)?)? RPAREN
built_in_max ::= BIF_MAX LPAREN parameter_expr (COMMA parameter_expr)* RPAREN
built_in_min ::= BIF_MIN LPAREN parameter_expr (COMMA parameter_expr)* RPAREN
built_in_overlay ::= BIF_OVERLAY LPAREN parameter_expr COMMA parameter_expr COMMA parameter_expr? COMMA parameter_expr? COMMA parameter_expr RPAREN
built_in_pos ::= BIF_POS LPAREN parameter_expr COMMA parameter_expr (COMMA parameter_expr? (COMMA parameter_expr)?)? RPAREN
built_in_qualify ::= BIF_QUALIFY LPAREN parameter_expr RPAREN
built_in_queued ::= BIF_QUEUED LPAREN RPAREN
built_in_random ::= BIF_RANDOM LPAREN (parameter_expr | (parameter_expr? COMMA parameter_expr? COMMA parameter_expr?)) RPAREN
built_in_reverse ::= BIF_REVERSE LPAREN parameter_expr RPAREN
built_in_right ::= BIF_RIGHT LPAREN parameter_expr COMMA parameter_expr (COMMA parameter_expr)? RPAREN
built_in_rxfuncadd ::= BIF_RXFUNCADD LPAREN parameter_expr COMMA parameter_expr (COMMA parameter_expr)? RPAREN
built_in_rxfuncdrop ::= BIF_RXFUNCDROP LPAREN parameter_expr RPAREN
built_in_rxfuncquery ::= BIF_RXFUNCQUERY LPAREN parameter_expr RPAREN
built_in_rxqueue ::= BIF_RXQUEUE LPAREN ((CREATE (COMMA parameter_expr)?) |
                (DELETE COMMA parameter_expr) |
                (EXIST COMMA parameter_expr) |
                (GET) |
                (OPEN COMMA parameter_expr) |
                (SET COMMA parameter_expr)) RPAREN
built_in_setlocal ::= BIF_SETLOCAL LPAREN RPAREN
built_in_sign ::= BIF_SIGN LPAREN parameter_expr RPAREN
built_in_sourceline ::= BIF_SOURCELINE LPAREN parameter_expr? RPAREN
built_in_space ::= BIF_SPACE LPAREN parameter_expr COMMA parameter_expr? (COMMA parameter_expr) RPAREN
built_in_stream ::= BIF_STREAM LPAREN parameter_expr COMMA (STATE | (COMMAND COMMA parameter_expr) | DESCRIPTION )? RPAREN // TODO
built_in_strip ::= BIF_STRIP LPAREN parameter_expr COMMA ("B" | parameter_expr)? (COMMA parameter_expr)? RPAREN
built_in_substr ::= BIF_SUBSTR LPAREN parameter_expr COMMA parameter_expr COMMA parameter_expr? (COMMA parameter_expr)? RPAREN
built_in_subword ::= BIF_SUBWORD LPAREN parameter_expr COMMA parameter_expr (COMMA parameter_expr) RPAREN
built_in_symbol ::= BIF_SYMBOL LPAREN parameter_expr RPAREN
built_in_time ::= BIF_TIME LPAREN ("N" | parameter_expr)? (COMMA parameter_expr COMMA ("N" | parameter_expr)?)? RPAREN
built_in_trace ::= BIF_TRACE LPAREN parameter_expr? RPAREN
built_in_translate ::= BIF_TRANSLATE LPAREN parameter_expr COMMA parameter_expr? COMMA parameter_expr? COMMA parameter_expr? COMMA parameter_expr? COMMA parameter_expr? RPAREN
built_in_trunc ::= BIF_TRUNC LPAREN parameter_expr (COMMA parameter_expr)? RPAREN
built_in_upper ::= BIF_UPPER LPAREN parameter_expr COMMA parameter_expr? (COMMA parameter_expr)? RPAREN
built_in_userid ::= BIF_USERID LPAREN RPAREN
built_in_value ::= BIF_VALUE LPAREN parameter_expr COMMA parameter_expr? (COMMA parameter_expr) RPAREN
built_in_var ::= BIF_VAR LPAREN parameter_expr RPAREN
built_in_verify ::= BIF_VERIFY LPAREN parameter_expr COMMA parameter_expr COMMA ("N" | parameter_expr)? COMMA parameter_expr? COMMA parameter_expr? RPAREN
built_in_word ::= BIF_WORD LPAREN parameter_expr COMMA parameter_expr RPAREN
built_in_wordindex ::= BIF_WORDINDEX LPAREN parameter_expr COMMA parameter_expr RPAREN
built_in_wordlength ::= BIF_WORDLENGTH LPAREN parameter_expr COMMA parameter_expr RPAREN
built_in_wordpos ::= BIF_WORDPOS LPAREN parameter_expr COMMA parameter_expr (COMMA parameter_expr)? RPAREN
built_in_words ::= BIF_WORD LPAREN parameter_expr RPAREN
built_in_x2b ::= BIF_X2B LPAREN parameter_expr RPAREN
built_in_x2c ::= BIF_X2C LPAREN parameter_expr RPAREN
built_in_x2d ::= BIF_X2D LPAREN parameter_expr (COMMA parameter_expr)? RPAREN
built_in_xrange ::= BIF_XRANGE LPAREN parameter_expr (COMMA parameter_expr)? RPAREN
