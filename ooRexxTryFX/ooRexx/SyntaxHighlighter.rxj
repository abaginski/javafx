::class SyntaxHighlighter public
::method init /* moving those imports into the init method will load them after the splash screen and that's good, because the user will then know, that he is waiting for something instead of looking at an empty screen */
  call bsf.import "java.util.Optional"   , "Optional"
  call bsf.import "java.util.Collections", "Collections"
  if .my.app~isPluginActive then do
    .local~clzDirective       = .my.app~appClzLdr~loadClass("org.oorexx.ide.lang.psi.OoRexxDirective")
    .local~clzDirectiveMethod = .my.app~appClzLdr~loadClass("org.oorexx.ide.lang.psi.OoRexxDirectiveMethod")
    .local~clzKeyword         = .my.app~appClzLdr~loadClass("org.oorexx.ide.lang.psi.OoRexxKeywordInstruction")
    .local~ooRexxParser       = .my.app~appClzLdr~loadClass("org.oorexx.ide.standalone.OoRexxStandaloneParser")
  end

::method accept
  use arg StyleSpans
  /*userData = .directory~new
  userData~StyleSpans = StyleSpans
  .Platform~runLater(bsfCreateRexxProxy(.StyleSpansApplier~new,userData,.java.lang.Runnable))*/
  codeArea = .TabManager~getInputArea
  --if StyleSpans~length = codeArea~getText~length then
  codeArea~setStyleSpans(0, StyleSpans)		-- apply the styleSpans built in the "call" method below
  Tab = .TabManager~getCurrentTab
  if Tab~getGraphic = .nil then
     Tab~setGraphic(.bsf~new("javafx.scene.image.ImageView", "resources/images/icon_savefile_15.png"))

::method test           /* although that's a very stupid name for a method, it's legit: called by "filter()" method in the TabManager Class */
  use arg ch
  return \ch~getInserted~equals(ch~getRemoved)
  
  
::method get
  task = bsfCreateRexxProxy(self,,"javafx.concurrent.Task")     -- execute the task in this class
  .Executor~execute(task)
  return task
	
	
/* called by the supplyTask method - Supplier Interface in the TabManager class */
::method call
	code = .TabManager~getInputArea~getText
	spansBuilder = .bsf~new("org.fxmisc.richtext.model.StyleSpansBuilder")
	FileElement = .ooRexxParser~parse(code)
	.local~tree = FileElement~getLighterAST
  root = .tree~getRoot
	.local~instructionLengthMap = .array~new
	call walkTheAST 0, root
	blacklist = "/n", "WHITE_SPACE"         -- those items will not get styled
 	loop map over .instructionLengthMap
		styleClass = map[1]~lower
		length = map[2]
		if blacklist~hasItem(styleClass) then
	    spansBuilder~add(.Collections~emptyList, length)
    else do
		  spansBuilder~add(.Collections~singleton(styleClass), length)
	    --say len pp(styleClass)
	  end
	end
	return spansBuilder~create

	
/* called by java.util.Function */
::method apply
	use arg res, slotDir	/* res as in result */
	if res~isSuccess then
		return .Optional~of(res~get)
	else do
		res~getFailure~printStackTrace
		return .Optional~empty
	end

::method unknown
  say "[information] unhandled call {"arg(1)"}"
  

/*
::class StyleSpansApplier
::method run
  use arg slotDir
  StyleSpans = slotDir~userData~StyleSpans

*/


::routine walkTheAST
  use arg level, root
  children = .tree~getChildren(root)
  loop child over children
    grandchildren = .tree~getChildren(child)
    /* information gathering */
    type = child~getTokenType~toString
    start = child~getStartOffset
    end = child~getEndOffset
    length = end - start
    --say " "~copies(level) || type || ":" start "-" end
    if grandchildren~size > 0 then
      call walkTheAST level+1, child
    else
      if length > 0 then do
        -- say type || start "-" end
        .instructionLengthMap~append(.array~of(makeString(type), length))
        --say "~"~copies(40)
      end
  end

/**
 ** this routine returns "POSIX" if the input string consists of only special punctuation characters, or the input string itself
 **/
::routine makeString
  use arg type
  select case type
    when ":" then
      return "DIRECTIVE"
    when ".false" then
      return "false"
    when ".true" then
      return "true"
    otherwise
      return .string~punct~makeArray("")~hasitem(type)~?("POSIX", type)
  end

::requires "BSF.CLS"        -- get Java Support